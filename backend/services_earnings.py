"""Earnings and Dividends Service - Core Business Logic"""

from motor.motor_asyncio import AsyncIOMotorDatabase
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Any, Optional
import logging
from models_earnings import (
    DividendDistribution,
    AssetRevenue,
    PortfolioHolding,
    AssetPerformance,
    DividendConfig
)

logger = logging.getLogger(__name__)

class EarningsService:
    """Service for managing dividends, ROI, and asset performance"""
    
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db
        self.platform_fee = 0.05  # 5% platform fee on transactions
        self.dividend_split = 0.80  # 80% to investors, 20% to platform
    
    # ========== REVENUE TRACKING ==========
    
    async def record_asset_revenue(self, 
                                   asset_id: str,
                                   amount: float,
                                   revenue_type: str,
                                   description: str) -> AssetRevenue:
        """Record revenue generated by an asset"""
        revenue = AssetRevenue(
            asset_id=asset_id,
            amount=amount,
            revenue_type=revenue_type,
            description=description
        )
        
        revenue_dict = revenue.model_dump()
        revenue_dict['date'] = revenue_dict['date'].isoformat()
        await self.db.asset_revenues.insert_one(revenue_dict)
        
        # Update asset performance
        await self._update_asset_performance(asset_id)
        
        logger.info(f"Revenue recorded: ${amount} for asset {asset_id}")
        return revenue
    
    async def get_asset_total_revenue(self, asset_id: str) -> float:
        """Get total revenue for an asset"""
        revenues = await self.db.asset_revenues.find(
            {"asset_id": asset_id},
            {"_id": 0}
        ).to_list(10000)
        
        return sum(r["amount"] for r in revenues)
    
    # ========== DIVIDEND DISTRIBUTION ==========
    
    async def calculate_dividends(self, asset_id: str, period: str) -> List[Dict[str, Any]]:
        """Calculate dividends for all token holders of an asset"""
        
        # Get asset revenue for period
        total_revenue = await self.get_asset_total_revenue(asset_id)
        
        if total_revenue <= 0:
            logger.info(f"No revenue to distribute for asset {asset_id}")
            return []
        
        # Calculate distributable amount (80% to investors)
        distributable = total_revenue * self.dividend_split
        
        # Get token info
        token = await self.db.tokens.find_one({"asset_id": asset_id}, {"_id": 0})
        if not token:
            logger.error(f"Token not found for asset {asset_id}")
            return []
        
        total_supply = token["total_supply"]
        tokens_sold = total_supply - token["available_supply"]
        
        if tokens_sold <= 0:
            logger.info(f"No tokens sold for asset {asset_id}")
            return []
        
        # Calculate per-token dividend
        dividend_per_token = distributable / tokens_sold
        
        # Get all holders
        holdings = await self.db.portfolio_holdings.find(
            {"asset_id": asset_id},
            {"_id": 0}
        ).to_list(10000)
        
        dividends = []
        for holding in holdings:
            dividend_amount = dividend_per_token * holding["quantity"]
            
            if dividend_amount >= 0.01:  # Min $0.01
                dividend = {
                    "token_id": token["id"],
                    "asset_id": asset_id,
                    "user_id": holding["user_id"],
                    "amount": round(dividend_amount, 2),
                    "tokens_held": holding["quantity"],
                    "period": period
                }
                dividends.append(dividend)
        
        logger.info(f"Calculated {len(dividends)} dividends totaling ${sum(d['amount'] for d in dividends):.2f}")
        return dividends
    
    async def distribute_dividends(self, asset_id: str, period: str) -> Dict[str, Any]:
        """Distribute dividends to all token holders"""
        
        # Calculate dividends
        dividends = await self.calculate_dividends(asset_id, period)
        
        if not dividends:
            return {
                "success": False,
                "message": "No dividends to distribute",
                "distributions": 0,
                "total_amount": 0
            }
        
        # Create distribution records
        distributions_created = 0
        total_distributed = 0.0
        
        for div_data in dividends:
            distribution = DividendDistribution(**div_data)
            distribution.status = "completed"  # Auto-complete for demo
            distribution.transaction_hash = f"0x{distribution.id[:16]}"
            
            dist_dict = distribution.model_dump()
            dist_dict['distribution_date'] = dist_dict['distribution_date'].isoformat()
            await self.db.dividend_distributions.insert_one(dist_dict)
            
            # Update user's portfolio holding
            await self.db.portfolio_holdings.update_one(
                {"user_id": div_data["user_id"], "token_id": div_data["token_id"]},
                {"$inc": {"total_dividends_received": div_data["amount"]}}
            )
            
            distributions_created += 1
            total_distributed += div_data["amount"]
        
        # Update asset performance
        await self._update_asset_performance(asset_id)
        
        logger.info(f"Distributed ${total_distributed:.2f} to {distributions_created} holders")
        
        return {
            "success": True,
            "distributions": distributions_created,
            "total_amount": round(total_distributed, 2),
            "period": period,
            "asset_id": asset_id
        }
    
    # ========== PORTFOLIO MANAGEMENT ==========
    
    async def create_or_update_holding(self,
                                      user_id: str,
                                      token_id: str,
                                      asset_id: str,
                                      quantity: int,
                                      price_per_token: float) -> PortfolioHolding:
        """Create or update user's token holding"""
        
        # Check if holding exists
        existing = await self.db.portfolio_holdings.find_one(
            {"user_id": user_id, "token_id": token_id},
            {"_id": 0}
        )
        
        if existing:
            # Update existing holding
            new_quantity = existing["quantity"] + quantity
            new_total = existing["total_invested"] + (quantity * price_per_token)
            new_avg_price = new_total / new_quantity
            
            await self.db.portfolio_holdings.update_one(
                {"user_id": user_id, "token_id": token_id},
                {
                    "$set": {
                        "quantity": new_quantity,
                        "total_invested": new_total,
                        "purchase_price_per_token": new_avg_price,
                        "last_updated": datetime.now(timezone.utc).isoformat()
                    }
                }
            )
            
            updated = await self.db.portfolio_holdings.find_one(
                {"user_id": user_id, "token_id": token_id},
                {"_id": 0}
            )
            
            if isinstance(updated.get('acquisition_date'), str):
                updated['acquisition_date'] = datetime.fromisoformat(updated['acquisition_date'])
            if isinstance(updated.get('last_updated'), str):
                updated['last_updated'] = datetime.fromisoformat(updated['last_updated'])
            
            return PortfolioHolding(**updated)
        else:
            # Create new holding
            holding = PortfolioHolding(
                user_id=user_id,
                token_id=token_id,
                asset_id=asset_id,
                quantity=quantity,
                purchase_price_per_token=price_per_token,
                total_invested=quantity * price_per_token,
                current_value=quantity * price_per_token
            )
            
            holding_dict = holding.model_dump()
            holding_dict['acquisition_date'] = holding_dict['acquisition_date'].isoformat()
            holding_dict['last_updated'] = holding_dict['last_updated'].isoformat()
            await self.db.portfolio_holdings.insert_one(holding_dict)
            
            return holding
    
    async def calculate_roi(self, user_id: str, token_id: str) -> Dict[str, float]:
        """Calculate ROI for a specific holding"""
        
        holding = await self.db.portfolio_holdings.find_one(
            {"user_id": user_id, "token_id": token_id},
            {"_id": 0}
        )
        
        if not holding:
            return {"roi_percentage": 0.0, "total_gain": 0.0}
        
        # Get current token price
        token = await self.db.tokens.find_one({"id": token_id}, {"_id": 0})
        current_price = token["price_per_token"] if token else holding["purchase_price_per_token"]
        
        current_value = holding["quantity"] * current_price
        total_invested = holding["total_invested"]
        dividends = holding.get("total_dividends_received", 0.0)
        
        total_value = current_value + dividends
        total_gain = total_value - total_invested
        roi_percentage = (total_gain / total_invested * 100) if total_invested > 0 else 0.0
        
        # Update holding with new ROI
        await self.db.portfolio_holdings.update_one(
            {"user_id": user_id, "token_id": token_id},
            {
                "$set": {
                    "current_value": current_value,
                    "roi_percentage": round(roi_percentage, 2),
                    "last_updated": datetime.now(timezone.utc).isoformat()
                }
            }
        )
        
        return {
            "roi_percentage": round(roi_percentage, 2),
            "total_gain": round(total_gain, 2),
            "current_value": round(current_value, 2),
            "total_invested": round(total_invested, 2),
            "total_dividends": round(dividends, 2)
        }
    
    async def get_user_portfolio(self, user_id: str) -> Dict[str, Any]:
        """Get complete portfolio for user"""
        
        holdings = await self.db.portfolio_holdings.find(
            {"user_id": user_id},
            {"_id": 0}
        ).to_list(1000)
        
        total_invested = 0.0
        total_current_value = 0.0
        total_dividends = 0.0
        
        portfolio_items = []
        
        for holding in holdings:
            # Calculate current ROI
            roi_data = await self.calculate_roi(user_id, holding["token_id"])
            
            # Get token and asset info
            token = await self.db.tokens.find_one({"id": holding["token_id"]}, {"_id": 0})
            asset = await self.db.rwa_assets.find_one({"id": holding["asset_id"]}, {"_id": 0})
            
            portfolio_items.append({
                "holding": holding,
                "token": token,
                "asset": asset,
                "performance": roi_data
            })
            
            total_invested += holding["total_invested"]
            total_current_value += roi_data["current_value"]
            total_dividends += roi_data["total_dividends"]
        
        total_gain = total_current_value + total_dividends - total_invested
        overall_roi = (total_gain / total_invested * 100) if total_invested > 0 else 0.0
        
        return {
            "user_id": user_id,
            "summary": {
                "total_invested": round(total_invested, 2),
                "current_value": round(total_current_value, 2),
                "total_dividends": round(total_dividends, 2),
                "total_gain": round(total_gain, 2),
                "roi_percentage": round(overall_roi, 2),
                "holdings_count": len(holdings)
            },
            "holdings": portfolio_items
        }
    
    # ========== ASSET PERFORMANCE ==========
    
    async def _update_asset_performance(self, asset_id: str):
        """Update performance metrics for an asset"""
        
        # Get revenue
        total_revenue = await self.get_asset_total_revenue(asset_id)
        
        # Get dividends paid
        dividends = await self.db.dividend_distributions.find(
            {"asset_id": asset_id, "status": "completed"},
            {"_id": 0}
        ).to_list(10000)
        total_dividends = sum(d["amount"] for d in dividends)
        
        # Get investor count
        holdings = await self.db.portfolio_holdings.find(
            {"asset_id": asset_id},
            {"_id": 0}
        ).to_list(10000)
        total_investors = len(set(h["user_id"] for h in holdings))
        
        # Calculate average ROI
        if holdings:
            roi_sum = sum(h.get("roi_percentage", 0.0) for h in holdings)
            average_roi = roi_sum / len(holdings)
        else:
            average_roi = 0.0
        
        # Performance score (0-100)
        revenue_score = min(total_revenue / 10000 * 50, 50)  # Max 50 points
        roi_score = min(average_roi / 2, 30)  # Max 30 points for 60%+ ROI
        investor_score = min(total_investors / 10 * 20, 20)  # Max 20 points
        performance_score = revenue_score + roi_score + investor_score
        
        # Get last dividend date
        last_div = None
        if dividends:
            last_div = max(d["distribution_date"] for d in dividends)
            if isinstance(last_div, str):
                last_div = datetime.fromisoformat(last_div)
        
        performance = {
            "asset_id": asset_id,
            "total_revenue": round(total_revenue, 2),
            "total_dividends_paid": round(total_dividends, 2),
            "total_investors": total_investors,
            "average_roi": round(average_roi, 2),
            "last_dividend_date": last_div.isoformat() if last_div else None,
            "performance_score": round(performance_score, 2),
            "metadata": {
                "last_updated": datetime.now(timezone.utc).isoformat()
            }
        }
        
        # Upsert performance record
        await self.db.asset_performance.update_one(
            {"asset_id": asset_id},
            {"$set": performance},
            upsert=True
        )
    
    async def get_asset_performance(self, asset_id: str) -> Dict[str, Any]:
        """Get performance metrics for an asset"""
        
        await self._update_asset_performance(asset_id)
        
        performance = await self.db.asset_performance.find_one(
            {"asset_id": asset_id},
            {"_id": 0}
        )
        
        if not performance:
            return {
                "asset_id": asset_id,
                "total_revenue": 0.0,
                "total_dividends_paid": 0.0,
                "total_investors": 0,
                "average_roi": 0.0,
                "performance_score": 0.0
            }
        
        return performance
    
    # ========== PLATFORM EARNINGS ==========
    
    async def get_platform_earnings(self) -> Dict[str, Any]:
        """Get platform's total earnings from fees"""
        
        # Transaction fees (5%)
        transactions = await self.db.transactions.find(
            {"status": "completed"},
            {"_id": 0}
        ).to_list(10000)
        
        transaction_fees = sum(t["total_amount"] * self.platform_fee for t in transactions)
        
        # Dividend retention (20%)
        all_revenues = await self.db.asset_revenues.find({}, {"_id": 0}).to_list(10000)
        total_revenue = sum(r["amount"] for r in all_revenues)
        dividend_retention = total_revenue * (1 - self.dividend_split)
        
        total_platform_earnings = transaction_fees + dividend_retention
        
        return {
            "transaction_fees": round(transaction_fees, 2),
            "dividend_retention": round(dividend_retention, 2),
            "total_earnings": round(total_platform_earnings, 2),
            "transactions_count": len(transactions),
            "total_revenue_generated": round(total_revenue, 2)
        }
